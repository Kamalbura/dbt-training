================================================================================
dbt FUNDAMENTALS â€” THE COMPLETE BEGINNER'S GUIDE
================================================================================
Author: dbt Training Course
Dataset: Shopify Orders (JayCutler.com)
================================================================================

TABLE OF CONTENTS:
  1. What is dbt?
  2. Why does dbt exist? (The Problem it Solves)
  3. How dbt Works (The Big Picture)
  4. Your dbt Project Structure Explained
  5. The dbt_project.yml File
  6. Profiles (Database Connection)
  7. Sources â€” source()
  8. Models â€” The Core of dbt
  9. ref() â€” The Magic Function
  10. Materializations (view, table, incremental, ephemeral)
  11. The DAG (Directed Acyclic Graph)
  12. dbt Commands You Need
  13. How It All Connects in YOUR Project


================================================================================
1. WHAT IS dbt?
================================================================================

dbt = "data build tool"

SIMPLE DEFINITION:
    dbt is a tool that lets you transform data in your warehouse using SQL.
    You write SELECT statements, and dbt turns them into tables/views for you.

ANALOGY â€” THE KITCHEN:
    Think of your data warehouse (BigQuery) as a kitchen:
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                 â”‚
    â”‚   RAW INGREDIENTS          dbt (THE CHEF)          DISHES      â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚   â”‚ Raw JSON  â”‚  â”€â”€â”€â”€â”€â”€â–º â”‚ SQL Models â”‚ â”€â”€â”€â”€â”€â”€â–º â”‚ Clean    â”‚  â”‚
    â”‚   â”‚ orders    â”‚           â”‚ (recipes) â”‚          â”‚ Tables   â”‚  â”‚
    â”‚   â”‚ messy     â”‚           â”‚           â”‚          â”‚ for BI   â”‚  â”‚
    â”‚   â”‚ nested    â”‚           â”‚ Transform â”‚          â”‚ dashbordsâ”‚  â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚                                                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    - Raw ingredients = your raw tables (Shopify orders JSONL)
    - Recipes = your SQL models (stg_shopify__orders.sql)
    - Dishes = clean tables for analytics (fct_orders, dim_customers)

WHAT dbt IS NOT:
    âœ— dbt does NOT extract data from APIs
    âœ— dbt does NOT load data into your warehouse
    âœ— dbt does NOT create dashboards
    
    dbt ONLY does the T in ELT (Extract â†’ Load â†’ Transform)
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Extract â”‚ â†’  â”‚  Load   â”‚ â†’  â”‚  Transform    â”‚
    â”‚         â”‚    â”‚         â”‚    â”‚  (dbt lives   â”‚
    â”‚ (Daton, â”‚    â”‚ (Python â”‚    â”‚   here!)      â”‚
    â”‚  APIs)  â”‚    â”‚  script)â”‚    â”‚               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


YOUR REAL EXAMPLE:
    Extract: Daton synced JayCutler.com Shopify orders
    Load:    scripts/load_jsonl_to_bq.py loaded JSONL â†’ BigQuery
    Transform: dbt models cleaned the data â†’ staging â†’ marts


================================================================================
2. WHY DOES dbt EXIST? (THE PROBLEM)
================================================================================

BEFORE dbt, data teams had these problems:

    PROBLEM 1: Messy SQL Everywhere
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Analysts wrote SQL queries directly in BigQuery console.
    No version control. No collaboration. No testing.
    
    "Who wrote this 500-line query? What does it do?
    Is it still correct? Can I change it safely?"

    PROBLEM 2: Copy-Paste Logic
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Same business logic repeated in 20 different queries.
    If the definition of "active customer" changes,
    you need to update all 20 queries manually.

    PROBLEM 3: No Testing
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    How do you know your data is correct?
    There's no automated way to check:
    - Are there duplicate order IDs?
    - Are there NULL customer IDs?
    - Does every order have a valid customer?

    PROBLEM 4: No Documentation
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "What does the 'orders_v3_final_FINAL' table contain?"
    Nobody knows. The person who created it left the company.


HOW dbt SOLVES THIS:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Problem             â”‚ dbt Solution                           â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Messy SQL           â”‚ Organized .sql files in folders        â”‚
    â”‚ Copy-paste logic    â”‚ ref() function â€” reuse models          â”‚
    â”‚ No testing          â”‚ Built-in tests (unique, not_null)      â”‚
    â”‚ No documentation    â”‚ YAML files + dbt docs generate        â”‚
    â”‚ No version control  â”‚ SQL files in Git â€” track changes       â”‚
    â”‚ No collaboration    â”‚ Pull requests, code review             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


================================================================================
3. HOW dbt WORKS (THE BIG PICTURE)
================================================================================

Step-by-step, what happens when you run `dbt run`:

    STEP 1: dbt reads your dbt_project.yml
            â†’ Learns project name, where files are, configurations
    
    STEP 2: dbt scans all .sql files in models/ folder
            â†’ Finds all your models
    
    STEP 3: dbt parses the Jinja ({{ }}) in each model
            â†’ Resolves ref(), source(), config() calls
    
    STEP 4: dbt builds a DAG (dependency graph)
            â†’ Figures out which model depends on which
            â†’ Determines execution ORDER
    
    STEP 5: dbt compiles SQL
            â†’ Replaces {{ ref('stg_shopify__orders') }}
              with actual table name like:
              `saras-bigquery.dbt_training_staging.stg_shopify__orders`
    
    STEP 6: dbt RUNS the SQL against BigQuery
            â†’ Creates VIEWs or TABLEs as configured
            â†’ Runs them in the correct dependency order
    
    STEP 7: dbt reports results
            â†’ "9 of 9 OK" = success!


YOUR REAL EXAMPLE â€” When you run `dbt run`:

    1. dbt reads dbt_project.yml â†’ project "shopify_analytics"
    
    2. dbt finds 9 models:
       - stg_shopify__orders
       - stg_shopify__order_line_items
       - stg_shopify__fulfillments
       - int_orders__enriched
       - int_customers__order_history
       - fct_orders
       - fct_daily_revenue
       - dim_customers
       - dim_products
    
    3. dbt resolves dependencies:
       source(orders) â†’ stg_orders â†’ int_orders â†’ fct_orders â†’ fct_daily_revenue
       
    4. dbt runs in ORDER:
       FIRST:  3 staging models (no dependencies on other models)
       SECOND: 2 intermediate models (depend on staging)
       THIRD:  4 mart models (depend on intermediate)
    
    5. dbt creates:
       - 5 VIEWS (staging + intermediate, because materialized='view')
       - 4 TABLES (marts, because materialized='table')


================================================================================
4. YOUR dbt PROJECT STRUCTURE
================================================================================

Let's map EVERY folder in your project:

    dbt-training/                          â† Project root
    â”‚
    â”œâ”€â”€ dbt_project.yml                    â† ğŸŸ¡ MASTER CONFIG FILE
    â”‚                                         Tells dbt how to run
    â”‚
    â”œâ”€â”€ models/                            â† ğŸŸ¢ YOUR SQL MODELS
    â”‚   â”œâ”€â”€ staging/                       â† Layer 1: Clean raw data
    â”‚   â”‚   â””â”€â”€ shopify/                   â† Grouped by data source
    â”‚   â”‚       â”œâ”€â”€ _shopify__sources.yml  â† Where raw data lives
    â”‚   â”‚       â”œâ”€â”€ _shopify__models.yml   â† Tests & documentation
    â”‚   â”‚       â”œâ”€â”€ stg_shopify__orders.sql
    â”‚   â”‚       â”œâ”€â”€ stg_shopify__order_line_items.sql
    â”‚   â”‚       â””â”€â”€ stg_shopify__fulfillments.sql
    â”‚   â”‚
    â”‚   â”œâ”€â”€ intermediate/                  â† Layer 2: Join & enrich
    â”‚   â”‚   â””â”€â”€ shopify/
    â”‚   â”‚       â”œâ”€â”€ _int_shopify__models.yml
    â”‚   â”‚       â”œâ”€â”€ int_orders__enriched.sql
    â”‚   â”‚       â””â”€â”€ int_customers__order_history.sql
    â”‚   â”‚
    â”‚   â””â”€â”€ marts/                         â† Layer 3: Final tables
    â”‚       â””â”€â”€ core/
    â”‚           â”œâ”€â”€ _core__models.yml
    â”‚           â”œâ”€â”€ fct_orders.sql
    â”‚           â”œâ”€â”€ fct_daily_revenue.sql
    â”‚           â”œâ”€â”€ dim_customers.sql
    â”‚           â””â”€â”€ dim_products.sql
    â”‚
    â”œâ”€â”€ seeds/                             â† ğŸ”µ CSV FILES â†’ TABLES
    â”‚   â””â”€â”€ country_codes.csv              â† Small lookup data
    â”‚
    â”œâ”€â”€ macros/                            â† ğŸŸ£ REUSABLE SQL/JINJA
    â”‚   â””â”€â”€ .gitkeep                       â† Empty for now
    â”‚
    â”œâ”€â”€ tests/                             â† ğŸ”´ CUSTOM SQL TESTS
    â”‚   â””â”€â”€ (empty for now)
    â”‚
    â”œâ”€â”€ snapshots/                         â† ğŸ“¸ SCD Type 2 tracking
    â”‚   â””â”€â”€ (empty for now)
    â”‚
    â”œâ”€â”€ analyses/                          â† ğŸ“Š Ad-hoc SQL (not materialized)
    â”‚
    â”œâ”€â”€ target/                            â† ğŸ—‚ï¸ COMPILED OUTPUT (gitignored)
    â”‚   â”œâ”€â”€ compiled/                      â† Human-readable compiled SQL
    â”‚   â”œâ”€â”€ run/                           â† Actual SQL executed
    â”‚   â”œâ”€â”€ manifest.json                  â† Project metadata
    â”‚   â””â”€â”€ run_results.json               â† Last run results
    â”‚
    â”œâ”€â”€ scripts/                           â† Python helper scripts
    â”‚   â”œâ”€â”€ load_jsonl_to_bq.py           â† Load raw data
    â”‚   â””â”€â”€ export_bq_tables.py           â† Export results
    â”‚
    â”œâ”€â”€ RAW_DATASETS/                      â† Source JSONL file
    â”‚   â””â”€â”€ bquxjob_...yourgpt.jsonl      â† 624 Shopify orders
    â”‚
    â”œâ”€â”€ docs/                              â† Learning materials
    â”‚
    â””â”€â”€ logs/                              â† dbt execution logs


================================================================================
5. THE dbt_project.yml FILE â€” LINE BY LINE
================================================================================

Let's walk through YOUR actual file:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ name: 'shopify_analytics'                                   â”‚
    â”‚                                                             â”‚
    â”‚ WHAT: Your project's unique name                            â”‚
    â”‚ RULES: lowercase, underscores only, no spaces               â”‚
    â”‚ USED FOR: Internal identification                           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ version: '1.0.0'                                            â”‚
    â”‚                                                             â”‚
    â”‚ WHAT: Semantic version of your project                      â”‚
    â”‚ FORMAT: major.minor.patch                                   â”‚
    â”‚ EXAMPLE: 1.0.0 â†’ first release, no changes yet             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ profile: 'default'                                          â”‚
    â”‚                                                             â”‚
    â”‚ WHAT: Which database connection to use                      â”‚
    â”‚ WHERE: Matches a profile in ~/.dbt/profiles.yml             â”‚
    â”‚ CONTAINS: project ID, dataset, credentials                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ model-paths: ["models"]                                     â”‚
    â”‚ seed-paths: ["seeds"]                                       â”‚
    â”‚ macro-paths: ["macros"]                                     â”‚
    â”‚ test-paths: ["tests"]                                       â”‚
    â”‚ snapshot-paths: ["snapshots"]                                â”‚
    â”‚                                                             â”‚
    â”‚ WHAT: Tells dbt WHERE to find each type of file             â”‚
    â”‚ DEFAULT: These are the standard folder names                â”‚
    â”‚ YOU CAN: Change them, but usually don't need to             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ vars:                                                       â”‚
    â”‚   raw_database: 'saras-bigquery'                            â”‚
    â”‚   raw_schema: 'raw_shopify'                                 â”‚
    â”‚                                                             â”‚
    â”‚ WHAT: Project-wide variables you can reference               â”‚
    â”‚ USED IN: _shopify__sources.yml as {{ var('raw_database') }} â”‚
    â”‚ OVERRIDE: dbt run --vars '{"raw_database": "prod-project"}' â”‚
    â”‚                                                             â”‚
    â”‚ WHY: So you can switch between dev/prod without             â”‚
    â”‚      editing source files!                                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ models:                                                     â”‚
    â”‚   shopify_analytics:        â† must match project name!      â”‚
    â”‚     staging:                                                 â”‚
    â”‚       +materialized: view   â† all staging = views           â”‚
    â”‚       +schema: staging      â† dataset: dbt_training_staging â”‚
    â”‚     marts:                                                   â”‚
    â”‚       +materialized: table  â† all marts = tables            â”‚
    â”‚       +schema: marts        â† dataset: dbt_training_marts   â”‚
    â”‚                                                             â”‚
    â”‚ WHAT: Configuration that CASCADES down folder structure      â”‚
    â”‚ The + prefix means "config for this folder and all below"   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


================================================================================
6. PROFILES â€” DATABASE CONNECTION
================================================================================

Your profiles.yml lives at:  C:\Users\Kamal Bura\.dbt\profiles.yml

It tells dbt HOW to connect to BigQuery:

    GENERIC EXAMPLE:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    default:                              # Profile name
      target: dev                         # Default target
      outputs:
        dev:                              # Target name
          type: bigquery                  # Database type
          method: oauth                   # Auth method
          project: saras-bigquery         # GCP project
          dataset: dbt_training           # Default dataset
          location: US                    # Region
          threads: 1                      # Parallel threads

    HOW THE SCHEMA SETTING WORKS:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Base dataset from profile: dbt_training
    
    Your staging +schema: staging
    â†’ Final dataset: dbt_training_staging
    
    Your marts +schema: marts
    â†’ Final dataset: dbt_training_marts
    
    Formula: {profile_dataset}_{schema}


================================================================================
7. SOURCES â€” source()
================================================================================

A SOURCE tells dbt:
    "Here's where my RAW data lives. Don't build it â€” just READ from it."

YOUR SOURCES FILE: models/staging/shopify/_shopify__sources.yml

    WHAT IT SAYS:
    
    sources:
      - name: shopify_raw          â† Nickname for this source
        database: {{ var('raw_database') }}    â† GCP project
        schema: {{ var('raw_schema') }}        â† BQ dataset
        tables:
          - name: orders            â† Actual table name

    HOW YOU USE IT IN SQL:
    
    SELECT * FROM {{ source('shopify_raw', 'orders') }}
    
    What dbt compiles this to:
    SELECT * FROM `saras-bigquery.raw_shopify.orders`

    WHY USE source() INSTEAD OF HARDCODING?
    
    âŒ Bad:  SELECT * FROM `saras-bigquery.raw_shopify.orders`
    âœ… Good: SELECT * FROM {{ source('shopify_raw', 'orders') }}
    
    Benefits:
    1. dbt tracks it in the DAG (lineage)
    2. You can test source columns
    3. Easy to swap dev/prod databases via vars
    4. Documentation auto-generates


GENERAL EXAMPLE â€” If you had Stripe data too:

    sources:
      - name: stripe_raw
        database: "{{ var('raw_database') }}"
        schema: raw_stripe
        tables:
          - name: payments
          - name: customers
          - name: refunds

    In SQL:
    SELECT * FROM {{ source('stripe_raw', 'payments') }}


================================================================================
8. MODELS â€” THE CORE OF dbt
================================================================================

A MODEL is simply a SQL SELECT statement saved as a .sql file.

    RULE: Every model = ONE SELECT statement
    RULE: The file name = the table/view name in BigQuery
    RULE: You NEVER write CREATE TABLE â€” dbt does it for you

    SIMPLEST POSSIBLE MODEL (hello_world.sql):
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    SELECT 'hello' AS greeting, CURRENT_DATE() AS today

    â†’ This creates a VIEW called "hello_world" in BigQuery
    â†’ With one row: | greeting: hello | today: 2026-02-06 |


YOUR REAL MODELS:

    stg_shopify__orders.sql
    â†’ File name becomes the VIEW name
    â†’ SELECT statement cleans and renames columns
    â†’ dbt runs: CREATE VIEW stg_shopify__orders AS (your SELECT)

    fct_orders.sql
    â†’ File name becomes the TABLE name
    â†’ dbt runs: CREATE TABLE fct_orders AS (your SELECT)


MODEL CONFIG â€” You can configure each model:

    {{ config(
        materialized='table',         -- table, view, incremental, ephemeral
        schema='marts',               -- which dataset
        tags=['core', 'daily'],       -- for filtering dbt run --select tag:core
        description='Order facts'     -- documentation
    ) }}

    SELECT ...


================================================================================
9. ref() â€” THE MAGIC FUNCTION
================================================================================

ref() is the MOST IMPORTANT function in dbt.

    WHAT IT DOES:
    - References another model by its file name
    - dbt automatically resolves to the correct database.schema.table
    - dbt tracks the dependency between models

    SYNTAX:
    {{ ref('model_name') }}
    
    NOTE: 'model_name' is the FILE NAME without .sql extension

    EXAMPLE:
    â”€â”€â”€â”€â”€â”€â”€â”€
    -- In fct_orders.sql:
    SELECT * FROM {{ ref('int_orders__enriched') }}
    
    -- dbt compiles this to:
    SELECT * FROM `saras-bigquery.dbt_training.int_orders__enriched`


    WHY ref() AND NOT HARDCODED TABLE NAMES?

    âŒ SELECT * FROM `saras-bigquery.dbt_training.int_orders__enriched`
    âœ… SELECT * FROM {{ ref('int_orders__enriched') }}

    REASON 1: PORTABILITY
    â†’ Works in dev AND prod without changes
    â†’ Dev might be `dev_dataset.int_orders__enriched`
    â†’ Prod might be `prod_dataset.int_orders__enriched`
    â†’ ref() figures it out automatically

    REASON 2: DEPENDENCY TRACKING
    â†’ dbt knows: fct_orders DEPENDS ON int_orders__enriched
    â†’ So it runs int_orders__enriched FIRST
    â†’ Then fct_orders SECOND
    â†’ Without ref(), dbt can't figure out the order

    REASON 3: LINEAGE
    â†’ dbt can draw a graph showing how data flows
    â†’ source â†’ staging â†’ intermediate â†’ marts
    â†’ This appears in `dbt docs generate`


YOUR REAL DEPENDENCY CHAIN:

    {{ source('shopify_raw', 'orders') }}       â† RAW TABLE (external)
         â”‚
         â”œâ”€â”€â–º {{ ref('stg_shopify__orders') }}          â† STAGING VIEW
         â”‚         â”‚
         â”‚         â”œâ”€â”€â–º {{ ref('int_orders__enriched') }}     â† INT VIEW
         â”‚         â”‚         â”‚
         â”‚         â”‚         â””â”€â”€â–º {{ ref('fct_orders') }}     â† MART TABLE
         â”‚         â”‚                   â”‚
         â”‚         â”‚                   â””â”€â”€â–º {{ ref('fct_daily_revenue') }}
         â”‚         â”‚
         â”‚         â””â”€â”€â–º {{ ref('int_customers__order_history') }}
         â”‚                   â”‚
         â”‚                   â””â”€â”€â–º {{ ref('dim_customers') }}
         â”‚
         â”œâ”€â”€â–º {{ ref('stg_shopify__order_line_items') }}
         â”‚         â”‚
         â”‚         â”œâ”€â”€â–º (joins into int_orders__enriched)
         â”‚         â”‚
         â”‚         â””â”€â”€â–º {{ ref('dim_products') }}
         â”‚
         â””â”€â”€â–º {{ ref('stg_shopify__fulfillments') }}
                   â”‚
                   â””â”€â”€â–º (joins into int_orders__enriched)


================================================================================
10. MATERIALIZATIONS â€” HOW dbt CREATES YOUR MODELS
================================================================================

Materialization = "how should dbt store this in the warehouse?"

There are 4 types:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ TYPE           â”‚ WHAT HAPPENS                                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ VIEW           â”‚ CREATE VIEW AS (your SELECT)                   â”‚
    â”‚                â”‚ â†’ No data stored                               â”‚
    â”‚                â”‚ â†’ Re-runs SELECT every time queried             â”‚
    â”‚                â”‚ â†’ Fast to create, slow to query (if complex)   â”‚
    â”‚                â”‚ â†’ Best for: staging, intermediate              â”‚
    â”‚                â”‚                                                â”‚
    â”‚ TABLE          â”‚ CREATE TABLE AS (your SELECT)                   â”‚
    â”‚                â”‚ â†’ Data physically stored                        â”‚
    â”‚                â”‚ â†’ Fast to query (pre-computed)                  â”‚
    â”‚                â”‚ â†’ Slow to create (must process all data)        â”‚
    â”‚                â”‚ â†’ Uses storage space                            â”‚
    â”‚                â”‚ â†’ Best for: marts (fct_, dim_)                 â”‚
    â”‚                â”‚                                                â”‚
    â”‚ INCREMENTAL    â”‚ First run: CREATE TABLE                         â”‚
    â”‚                â”‚ Next runs: INSERT only NEW/CHANGED rows         â”‚
    â”‚                â”‚ â†’ Efficient for large datasets                  â”‚
    â”‚                â”‚ â†’ Best for: append-only event data              â”‚
    â”‚                â”‚ â†’ We'll learn this in Phase 4                  â”‚
    â”‚                â”‚                                                â”‚
    â”‚ EPHEMERAL      â”‚ NOT created in warehouse at all                 â”‚
    â”‚                â”‚ â†’ Inlined as a CTE in downstream models         â”‚
    â”‚                â”‚ â†’ No storage, no separate query                 â”‚
    â”‚                â”‚ â†’ Best for: simple helper transformations       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


GENERAL EXAMPLE â€” Same data, different materializations:

    -- As VIEW (staging):
    {{ config(materialized='view') }}
    SELECT id, name, price FROM raw.products

    -- BigQuery sees: CREATE VIEW products AS SELECT id, name, price FROM raw.products
    -- When you query it, BigQuery re-runs the SELECT every time


    -- As TABLE (mart):
    {{ config(materialized='table') }}
    SELECT id, name, price FROM raw.products

    -- BigQuery sees: CREATE TABLE products AS SELECT id, name, price FROM raw.products
    -- Data is stored. Querying is instant. But table is "stale" until dbt runs again.


    -- As EPHEMERAL (helper):
    {{ config(materialized='ephemeral') }}
    SELECT id, name, price FROM raw.products

    -- NOT created at all! Instead, when another model does ref('products'),
    -- dbt injects it as a CTE:
    -- WITH products AS (SELECT id, name, price FROM raw.products)
    -- SELECT * FROM products


YOUR PROJECT's MATERIALIZATION STRATEGY:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Layer          â”‚ Materialization â”‚ Why                    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ stg_orders     â”‚ VIEW           â”‚ Cheap, always fresh    â”‚
    â”‚ stg_line_items â”‚ VIEW           â”‚ Cheap, always fresh    â”‚
    â”‚ stg_fulfills   â”‚ VIEW           â”‚ Cheap, always fresh    â”‚
    â”‚ int_enriched   â”‚ VIEW           â”‚ Reusable, no storage   â”‚
    â”‚ int_customers  â”‚ VIEW           â”‚ Reusable, no storage   â”‚
    â”‚ fct_orders     â”‚ TABLE          â”‚ Fast queries for BI    â”‚
    â”‚ fct_daily_rev  â”‚ TABLE          â”‚ Fast queries for BI    â”‚
    â”‚ dim_customers  â”‚ TABLE          â”‚ Fast queries for BI    â”‚
    â”‚ dim_products   â”‚ TABLE          â”‚ Fast queries for BI    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


================================================================================
11. THE DAG â€” DIRECTED ACYCLIC GRAPH
================================================================================

DAG = the dependency tree of your models.

    D = Directed (arrows go one way: source â†’ target)
    A = Acyclic (no circular dependencies allowed!)
    G = Graph (visual representation of relationships)

YOUR DAG:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  raw_shopify.  â”‚
    â”‚    orders      â”‚     (SOURCE â€” external table)
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              â”‚                                   â”‚
    â–¼              â–¼                                   â–¼
  stg_orders   stg_line_items                    stg_fulfillments
    â”‚              â”‚                                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚              â”‚                                   â”‚
    â–¼              â–¼                                   â–¼
  int_orders__enriched                    int_customers__order_history
    â”‚                                              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
    â–¼           â–¼                                  â–¼
  fct_orders  fct_daily_revenue              dim_customers
                                              
              dim_products â—„â”€â”€ stg_line_items

    WHY THE DAG MATTERS:
    1. dbt runs models in the RIGHT ORDER (parents before children)
    2. If stg_orders fails, dbt won't try to run fct_orders
    3. You can see how a change in staging affects downstream tables
    4. `dbt docs generate` creates an interactive visual DAG


    CIRCULAR DEPENDENCY â€” WHAT YOU CAN'T DO:

    âŒ model_a references model_b AND model_b references model_a
    
    -- model_a.sql
    SELECT * FROM {{ ref('model_b') }}    â† depends on B
    
    -- model_b.sql  
    SELECT * FROM {{ ref('model_a') }}    â† depends on A âŒ CIRCULAR!
    
    dbt will ERROR: "Found a cycle in the dependency graph"


================================================================================
12. dbt COMMANDS YOU NEED
================================================================================

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Command              â”‚ What It Does                             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ dbt run              â”‚ Build ALL models (create tables/views)   â”‚
    â”‚ dbt test             â”‚ Run ALL tests defined in YAML            â”‚
    â”‚ dbt build            â”‚ Run + test (both in correct order)       â”‚
    â”‚ dbt run -s model_x   â”‚ Run ONLY model_x                       â”‚
    â”‚ dbt run -s +model_x  â”‚ Run model_x AND all its parents         â”‚
    â”‚ dbt run -s model_x+  â”‚ Run model_x AND all its children        â”‚
    â”‚ dbt seed             â”‚ Load all CSV files from seeds/ folder    â”‚
    â”‚ dbt compile          â”‚ Compile SQL (don't run â€” just preview)   â”‚
    â”‚ dbt docs generate    â”‚ Generate documentation website           â”‚
    â”‚ dbt docs serve       â”‚ Open documentation in browser            â”‚
    â”‚ dbt clean            â”‚ Delete target/ and dbt_packages/         â”‚
    â”‚ dbt debug            â”‚ Check connection and configuration       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    SELECTOR SYNTAX (powerful!):
    
    dbt run -s staging.*              # All staging models
    dbt run -s marts.core.*           # All core marts
    dbt run -s tag:daily              # All models tagged 'daily'
    dbt run -s +fct_orders            # fct_orders + all upstream
    dbt run -s fct_orders+            # fct_orders + all downstream
    dbt test -s stg_shopify__orders   # Test only this model


================================================================================
13. HOW IT ALL CONNECTS IN YOUR PROJECT
================================================================================

Let's trace a REAL data journey through YOUR project:

    STEP 1: Raw Data Arrives
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    624 Shopify orders from JayCutler.com in JSONL format.
    Each order has nested arrays: line_items, fulfillments, customer.
    
    File: RAW_DATASETS/bquxjob_...yourgpt.jsonl
    
    Order #JC730928:
    - Customer: Jason Andrews (Ohio)
    - Product: 3 Pack Multi Flavor Carnitine ($90.00)
    - Discount: $40.00 (TikTok Platform & Seller)
    - Total: $53.38
    - Shipped: DHL eCommerce

    STEP 2: Load to BigQuery
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    scripts/load_jsonl_to_bq.py â†’ `saras-bigquery.raw_shopify.orders`
    
    Now the data is in BigQuery, but it's MESSY:
    - Column names like "id" (not specific), "total_price" (unclear)
    - Nested arrays take up huge text blobs
    - Duplicate rows from multiple sync batches
    - Some columns are strings but should be numbers

    STEP 3: dbt Source Declaration
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _shopify__sources.yml tells dbt:
    "There's a table called 'orders' in raw_shopify dataset."
    
    Now you can write: {{ source('shopify_raw', 'orders') }}

    STEP 4: Staging Models (dbt run)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    stg_shopify__orders.sql:
    - Renames: id â†’ order_id, total_price â†’ total_amount
    - Casts: "50.00" â†’ 50.00 (STRING to FLOAT64)
    - Extracts: customer[0].id â†’ customer_id
    - Deduplicates: ROW_NUMBER() keeps latest sync
    - Adds: window functions (customer_order_sequence, etc.)
    - Excludes: nested arrays (handled separately)
    
    stg_shopify__order_line_items.sql:
    - UNNESTs: line_items array â†’ separate rows
    - Result: Order with 3 products â†’ 3 rows
    
    stg_shopify__fulfillments.sql:
    - UNNESTs: fulfillments array â†’ separate rows
    - Calculates: hours_to_fulfill, days_to_fulfill

    STEP 5: Intermediate Models
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    int_orders__enriched.sql:
    - Joins: orders + line_item_summary + fulfillment_summary
    - Adds: line_item_count, total_quantity, is_canceled
    
    int_customers__order_history.sql:
    - Aggregates: all orders per customer
    - Creates: RFM segments (frequency, recency, value)

    STEP 6: Mart Models
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    fct_orders:      One row per order, all metrics
    fct_daily_revenue: One row per day, aggregated revenue
    dim_customers:   One row per customer, RFM segmentation
    dim_products:    One row per product, sales rankings

    STEP 7: Tests Validate Everything
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    49 tests check:
    - order_id is unique and not null
    - customer_id exists in dim_customers
    - payment_status has valid values only
    - All foreign keys are valid


================================================================================
SUMMARY â€” dbt IN ONE SENTENCE
================================================================================

    dbt lets you write SQL SELECT statements as files,
    organizes them into layers (staging â†’ intermediate â†’ marts),
    automatically figures out dependencies (DAG),
    creates tables/views in your warehouse,
    and tests that the data is correct.

    That's it. That's dbt.


================================================================================
NEXT: Read 02_models_and_modelling.txt for a deep dive into models
================================================================================
